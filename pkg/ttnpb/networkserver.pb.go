// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: lorawan-stack/api/networkserver.proto

package ttnpb

import (
	context "context"
	fmt "fmt"
	_ "github.com/TheThingsIndustries/protoc-gen-go-flags/annotations"
	_ "github.com/envoyproxy/protoc-gen-validate/validate"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	golang_proto "github.com/golang/protobuf/proto"
	go_thethings_network_lorawan_stack_v3_pkg_types "go.thethings.network/lorawan-stack/v3/pkg/types"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Response of GenerateDevAddr.
type GenerateDevAddrResponse struct {
	DevAddr              *go_thethings_network_lorawan_stack_v3_pkg_types.DevAddr `protobuf:"bytes,1,opt,name=dev_addr,json=devAddr,proto3,customtype=go.thethings.network/lorawan-stack/v3/pkg/types.DevAddr" json:"dev_addr,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                                 `json:"-"`
	XXX_unrecognized     []byte                                                   `json:"-"`
	XXX_sizecache        int32                                                    `json:"-"`
}

func (m *GenerateDevAddrResponse) Reset()         { *m = GenerateDevAddrResponse{} }
func (m *GenerateDevAddrResponse) String() string { return proto.CompactTextString(m) }
func (*GenerateDevAddrResponse) ProtoMessage()    {}
func (*GenerateDevAddrResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c77e7504ad1081b8, []int{0}
}
func (m *GenerateDevAddrResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GenerateDevAddrResponse.Unmarshal(m, b)
}
func (m *GenerateDevAddrResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GenerateDevAddrResponse.Marshal(b, m, deterministic)
}
func (m *GenerateDevAddrResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GenerateDevAddrResponse.Merge(m, src)
}
func (m *GenerateDevAddrResponse) XXX_Size() int {
	return xxx_messageInfo_GenerateDevAddrResponse.Size(m)
}
func (m *GenerateDevAddrResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GenerateDevAddrResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GenerateDevAddrResponse proto.InternalMessageInfo

// Request of GetDefaultMACSettings.
type GetDefaultMACSettingsRequest struct {
	FrequencyPlanId      string     `protobuf:"bytes,1,opt,name=frequency_plan_id,json=frequencyPlanId,proto3" json:"frequency_plan_id,omitempty"`
	LorawanPhyVersion    PHYVersion `protobuf:"varint,2,opt,name=lorawan_phy_version,json=lorawanPhyVersion,proto3,enum=ttn.lorawan.v3.PHYVersion" json:"lorawan_phy_version,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *GetDefaultMACSettingsRequest) Reset()         { *m = GetDefaultMACSettingsRequest{} }
func (m *GetDefaultMACSettingsRequest) String() string { return proto.CompactTextString(m) }
func (*GetDefaultMACSettingsRequest) ProtoMessage()    {}
func (*GetDefaultMACSettingsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_c77e7504ad1081b8, []int{1}
}
func (m *GetDefaultMACSettingsRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetDefaultMACSettingsRequest.Unmarshal(m, b)
}
func (m *GetDefaultMACSettingsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetDefaultMACSettingsRequest.Marshal(b, m, deterministic)
}
func (m *GetDefaultMACSettingsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetDefaultMACSettingsRequest.Merge(m, src)
}
func (m *GetDefaultMACSettingsRequest) XXX_Size() int {
	return xxx_messageInfo_GetDefaultMACSettingsRequest.Size(m)
}
func (m *GetDefaultMACSettingsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetDefaultMACSettingsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetDefaultMACSettingsRequest proto.InternalMessageInfo

func (m *GetDefaultMACSettingsRequest) GetFrequencyPlanId() string {
	if m != nil {
		return m.FrequencyPlanId
	}
	return ""
}

func (m *GetDefaultMACSettingsRequest) GetLorawanPhyVersion() PHYVersion {
	if m != nil {
		return m.LorawanPhyVersion
	}
	return PHYVersion_PHY_UNKNOWN
}

func init() {
	proto.RegisterType((*GenerateDevAddrResponse)(nil), "ttn.lorawan.v3.GenerateDevAddrResponse")
	golang_proto.RegisterType((*GenerateDevAddrResponse)(nil), "ttn.lorawan.v3.GenerateDevAddrResponse")
	proto.RegisterType((*GetDefaultMACSettingsRequest)(nil), "ttn.lorawan.v3.GetDefaultMACSettingsRequest")
	golang_proto.RegisterType((*GetDefaultMACSettingsRequest)(nil), "ttn.lorawan.v3.GetDefaultMACSettingsRequest")
}

func init() {
	proto.RegisterFile("lorawan-stack/api/networkserver.proto", fileDescriptor_c77e7504ad1081b8)
}
func init() {
	golang_proto.RegisterFile("lorawan-stack/api/networkserver.proto", fileDescriptor_c77e7504ad1081b8)
}

var fileDescriptor_c77e7504ad1081b8 = []byte{
	// 889 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x55, 0x41, 0x6f, 0x1b, 0x45,
	0x14, 0x66, 0xdd, 0x90, 0x86, 0x51, 0x94, 0x36, 0xd3, 0x50, 0x52, 0xb7, 0xd0, 0xc8, 0x05, 0x51,
	0x05, 0xbc, 0x2b, 0x39, 0x42, 0x48, 0xe1, 0x82, 0x8d, 0x83, 0x13, 0x44, 0xa2, 0xd4, 0x31, 0x95,
	0xda, 0xcb, 0x6a, 0xb2, 0xf3, 0xbc, 0x3b, 0xf2, 0x7a, 0x66, 0x3b, 0x33, 0x5e, 0x77, 0x15, 0xe5,
	0xd2, 0x03, 0x67, 0x24, 0xc4, 0x99, 0x2b, 0xe2, 0xc0, 0x01, 0x0e, 0x5c, 0x10, 0xe2, 0x17, 0x70,
	0xe1, 0xc6, 0x81, 0x0b, 0xfc, 0x02, 0x8e, 0x3d, 0x21, 0xcf, 0xae, 0x13, 0x7b, 0xd7, 0x46, 0x09,
	0x20, 0x6e, 0x6f, 0xfd, 0xbe, 0xf7, 0xbd, 0x6f, 0xbe, 0xf7, 0x66, 0x8c, 0xde, 0x08, 0x85, 0x24,
	0x43, 0xc2, 0xab, 0x4a, 0x13, 0xaf, 0xe7, 0x90, 0x88, 0x39, 0x1c, 0xf4, 0x50, 0xc8, 0x9e, 0x02,
	0x19, 0x83, 0xb4, 0x23, 0x29, 0xb4, 0xc0, 0x2b, 0x5a, 0x73, 0x3b, 0x83, 0xda, 0xf1, 0x56, 0xb9,
	0xe9, 0x33, 0x1d, 0x0c, 0x8e, 0x6d, 0x4f, 0xf4, 0x9d, 0x4e, 0x00, 0x9d, 0x80, 0x71, 0x5f, 0xed,
	0x71, 0x3a, 0x50, 0x5a, 0x32, 0x50, 0x8e, 0xa9, 0xf2, 0xaa, 0x3e, 0xf0, 0xaa, 0x2f, 0xaa, 0xdd,
	0x90, 0xf8, 0xca, 0x21, 0x9c, 0x0b, 0x4d, 0x34, 0x13, 0x5c, 0xa5, 0xac, 0xe5, 0xfa, 0x04, 0x0b,
	0xf0, 0x58, 0x24, 0x91, 0x14, 0x4f, 0x93, 0xc9, 0xe2, 0x98, 0x84, 0x8c, 0x12, 0x0d, 0x4e, 0x21,
	0xc8, 0x28, 0xaa, 0x13, 0x14, 0xbe, 0xf0, 0x45, 0x5a, 0x7c, 0x3c, 0xe8, 0x9a, 0x2f, 0xf3, 0x61,
	0xa2, 0x0c, 0x7e, 0xc7, 0x17, 0xc2, 0x0f, 0xc1, 0x9c, 0xb3, 0xa8, 0xe7, 0x76, 0x96, 0x3d, 0xe3,
	0x80, 0x7e, 0xa4, 0x93, 0x2c, 0x59, 0x29, 0x3a, 0x05, 0x9c, 0xba, 0x14, 0x62, 0xe6, 0x8d, 0xd5,
	0xdc, 0x2b, 0x62, 0x18, 0x05, 0xae, 0x59, 0x97, 0x81, 0x1c, 0x77, 0xd9, 0x28, 0x82, 0xfa, 0xa0,
	0x14, 0xf1, 0x61, 0x8c, 0xb8, 0x5b, 0x44, 0x8c, 0xbd, 0x37, 0x80, 0xca, 0x13, 0xf4, 0x4a, 0x0b,
	0x38, 0x48, 0xa2, 0xa1, 0x09, 0x71, 0x9d, 0x52, 0xd9, 0x06, 0x15, 0x09, 0xae, 0x00, 0x3f, 0x44,
	0x4b, 0x14, 0x62, 0x97, 0x50, 0x2a, 0xd7, 0xad, 0x0d, 0xeb, 0xfe, 0x72, 0xe3, 0xbd, 0x5f, 0x7f,
	0xbb, 0xfb, 0xae, 0x2f, 0x6c, 0x1d, 0x80, 0x36, 0x73, 0xb2, 0xb3, 0x09, 0x3b, 0xd3, 0x6d, 0xe2,
	0x2d, 0x27, 0xea, 0xf9, 0x8e, 0x4e, 0x22, 0x50, 0xf6, 0x98, 0xf6, 0x2a, 0x4d, 0x83, 0xca, 0x77,
	0x16, 0xba, 0xd3, 0x02, 0xdd, 0x84, 0x2e, 0x19, 0x84, 0x7a, 0xbf, 0xfe, 0xc1, 0x11, 0x68, 0x3d,
	0x62, 0x6b, 0xc3, 0x93, 0x01, 0x28, 0x8d, 0xb7, 0xd0, 0x6a, 0x57, 0x8e, 0x62, 0xee, 0x25, 0x6e,
	0x14, 0x12, 0xee, 0x32, 0x6a, 0x14, 0xbc, 0xd4, 0xb8, 0xfa, 0xbc, 0xb1, 0x20, 0x4b, 0xeb, 0xef,
	0xb7, 0xaf, 0x9d, 0x21, 0x0e, 0x43, 0xc2, 0xf7, 0x28, 0xee, 0xa0, 0x1b, 0x99, 0x08, 0x37, 0x0a,
	0x12, 0x37, 0x06, 0xa9, 0x98, 0xe0, 0xeb, 0xa5, 0x0d, 0xeb, 0xfe, 0x4a, 0xad, 0x6c, 0x4f, 0x6f,
	0x9d, 0x7d, 0xb8, 0xfb, 0xe8, 0x61, 0x8a, 0x68, 0x2c, 0x3d, 0x6f, 0xbc, 0xf8, 0xcc, 0x2a, 0x5d,
	0xb7, 0xda, 0xab, 0x19, 0xe0, 0x30, 0x48, 0xb2, 0xe4, 0xf6, 0xd2, 0x9f, 0x5f, 0xdf, 0x5a, 0x58,
	0x7a, 0xe1, 0xba, 0x55, 0xfb, 0xb2, 0x84, 0x4a, 0x07, 0x0a, 0x07, 0xe8, 0x5a, 0xce, 0x2f, 0x7c,
	0xd3, 0x4e, 0x87, 0x6d, 0x8f, 0x87, 0x6d, 0xef, 0x8c, 0x86, 0x5d, 0x7e, 0x33, 0xdf, 0x74, 0x8e,
	0xd1, 0x95, 0xb5, 0x67, 0xbf, 0xfc, 0xf1, 0x79, 0x69, 0x05, 0x2f, 0x3b, 0x5c, 0x39, 0x63, 0xcb,
	0xf1, 0x37, 0x16, 0x7a, 0x79, 0xa6, 0x4d, 0xf8, 0xed, 0x22, 0xf1, 0x7c, 0x37, 0xcb, 0xb7, 0xf3,
	0xe8, 0x09, 0x4c, 0xe5, 0x23, 0xd3, 0xba, 0x89, 0x1b, 0x69, 0x6b, 0xc3, 0xe1, 0xf6, 0x89, 0xe7,
	0xaa, 0x0c, 0xe1, 0x9c, 0x14, 0x46, 0x71, 0xea, 0x9c, 0xcc, 0x70, 0xfa, 0xb4, 0xf6, 0x59, 0x09,
	0x2d, 0xd4, 0xd5, 0x81, 0xc2, 0x1d, 0xb4, 0xd6, 0x14, 0x43, 0x1e, 0x32, 0xde, 0x7b, 0x30, 0x80,
	0x01, 0xb4, 0x21, 0x0a, 0x89, 0x07, 0xf8, 0xf5, 0xbc, 0x92, 0x1c, 0x2a, 0xd5, 0x3b, 0xc7, 0x4e,
	0xfc, 0x00, 0xad, 0x4e, 0xe1, 0x0f, 0x07, 0x2a, 0xf8, 0x97, 0x94, 0x6e, 0x8e, 0xf2, 0x63, 0xa6,
	0x74, 0x91, 0x72, 0x87, 0xd3, 0xa6, 0xb9, 0x9a, 0x7b, 0xe7, 0x17, 0xb0, 0x5c, 0x40, 0xd5, 0xa3,
	0x28, 0x64, 0x9e, 0x79, 0x04, 0xc6, 0x9c, 0xaa, 0xf6, 0x95, 0x85, 0x16, 0x5a, 0x23, 0x4b, 0x76,
	0xd0, 0xf2, 0x2e, 0xe1, 0x34, 0x84, 0x4f, 0xa2, 0x51, 0x06, 0xbf, 0x9a, 0x2f, 0x4f, 0x7f, 0xdf,
	0x4f, 0x6f, 0xef, 0x5c, 0xc1, 0x8f, 0xd0, 0xcd, 0x36, 0x44, 0x42, 0xea, 0xce, 0xd3, 0xba, 0xd7,
	0xe3, 0x62, 0x18, 0x02, 0xf5, 0xfb, 0xc0, 0x35, 0x2e, 0x2e, 0x1b, 0xd1, 0x30, 0x24, 0x49, 0x1e,
	0x38, 0x8f, 0xba, 0xf6, 0xc3, 0x22, 0xba, 0x71, 0xa0, 0xce, 0xce, 0xda, 0x06, 0x9f, 0x29, 0x2d,
	0x13, 0xfc, 0xad, 0x85, 0xae, 0xb4, 0x40, 0xe3, 0x7b, 0x33, 0x96, 0x6e, 0x02, 0x9d, 0x1a, 0x7d,
	0x6b, 0xae, 0x77, 0x95, 0x9e, 0xd9, 0x34, 0xc0, 0xde, 0x68, 0xd3, 0xc8, 0xb9, 0x59, 0xca, 0x39,
	0x39, 0x7f, 0xfc, 0x5c, 0x46, 0x95, 0x3d, 0x91, 0x9c, 0xf1, 0x7d, 0xea, 0xa4, 0xd0, 0x62, 0xdd,
	0x59, 0x78, 0x8a, 0x3f, 0x2d, 0xa1, 0x2b, 0x47, 0xb3, 0x44, 0x1f, 0x5d, 0x4e, 0xf4, 0x8f, 0x96,
	0x51, 0xfd, 0xbd, 0x55, 0xfe, 0x5b, 0xd9, 0xf6, 0x3f, 0x94, 0x6d, 0x4f, 0xcb, 0xde, 0xb6, 0x36,
	0x1f, 0xef, 0x57, 0x76, 0xff, 0xab, 0x4e, 0xdb, 0xd6, 0x26, 0xfe, 0xd9, 0x42, 0x6b, 0x6d, 0x50,
	0xa0, 0x3f, 0x24, 0x9e, 0x16, 0x32, 0xc9, 0x9e, 0x09, 0x85, 0xdf, 0xca, 0x1f, 0xda, 0xa0, 0xea,
	0x9c, 0x5e, 0x72, 0xac, 0xdc, 0x18, 0x14, 0xd4, 0xfe, 0x8f, 0xb1, 0x8e, 0x0e, 0xf4, 0x85, 0x85,
	0x16, 0x9b, 0x10, 0x82, 0x86, 0x0b, 0x5e, 0xd4, 0x39, 0xfb, 0x5e, 0xd9, 0x37, 0xc2, 0x5b, 0x9b,
	0x3b, 0x45, 0xe1, 0x17, 0x56, 0x7a, 0x2e, 0xad, 0xf1, 0xce, 0x4f, 0xbf, 0xbf, 0x66, 0x3d, 0x76,
	0x2e, 0xf1, 0xe7, 0xa8, 0x79, 0x74, 0x7c, 0xbc, 0x68, 0x54, 0x6d, 0xfd, 0x15, 0x00, 0x00, 0xff,
	0xff, 0x0a, 0x67, 0x14, 0x6c, 0x3d, 0x09, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// NsClient is the client API for Ns service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type NsClient interface {
	// GenerateDevAddr requests a device address assignment from the Network Server.
	GenerateDevAddr(ctx context.Context, in *types.Empty, opts ...grpc.CallOption) (*GenerateDevAddrResponse, error)
	// GetDefaultMACSettings retrieves the default MAC settings for a frequency plan.
	GetDefaultMACSettings(ctx context.Context, in *GetDefaultMACSettingsRequest, opts ...grpc.CallOption) (*MACSettings, error)
}

type nsClient struct {
	cc *grpc.ClientConn
}

func NewNsClient(cc *grpc.ClientConn) NsClient {
	return &nsClient{cc}
}

func (c *nsClient) GenerateDevAddr(ctx context.Context, in *types.Empty, opts ...grpc.CallOption) (*GenerateDevAddrResponse, error) {
	out := new(GenerateDevAddrResponse)
	err := c.cc.Invoke(ctx, "/ttn.lorawan.v3.Ns/GenerateDevAddr", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nsClient) GetDefaultMACSettings(ctx context.Context, in *GetDefaultMACSettingsRequest, opts ...grpc.CallOption) (*MACSettings, error) {
	out := new(MACSettings)
	err := c.cc.Invoke(ctx, "/ttn.lorawan.v3.Ns/GetDefaultMACSettings", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NsServer is the server API for Ns service.
type NsServer interface {
	// GenerateDevAddr requests a device address assignment from the Network Server.
	GenerateDevAddr(context.Context, *types.Empty) (*GenerateDevAddrResponse, error)
	// GetDefaultMACSettings retrieves the default MAC settings for a frequency plan.
	GetDefaultMACSettings(context.Context, *GetDefaultMACSettingsRequest) (*MACSettings, error)
}

// UnimplementedNsServer can be embedded to have forward compatible implementations.
type UnimplementedNsServer struct {
}

func (*UnimplementedNsServer) GenerateDevAddr(ctx context.Context, req *types.Empty) (*GenerateDevAddrResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateDevAddr not implemented")
}
func (*UnimplementedNsServer) GetDefaultMACSettings(ctx context.Context, req *GetDefaultMACSettingsRequest) (*MACSettings, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDefaultMACSettings not implemented")
}

func RegisterNsServer(s *grpc.Server, srv NsServer) {
	s.RegisterService(&_Ns_serviceDesc, srv)
}

func _Ns_GenerateDevAddr_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NsServer).GenerateDevAddr(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ttn.lorawan.v3.Ns/GenerateDevAddr",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NsServer).GenerateDevAddr(ctx, req.(*types.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ns_GetDefaultMACSettings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDefaultMACSettingsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NsServer).GetDefaultMACSettings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ttn.lorawan.v3.Ns/GetDefaultMACSettings",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NsServer).GetDefaultMACSettings(ctx, req.(*GetDefaultMACSettingsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Ns_serviceDesc = grpc.ServiceDesc{
	ServiceName: "ttn.lorawan.v3.Ns",
	HandlerType: (*NsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GenerateDevAddr",
			Handler:    _Ns_GenerateDevAddr_Handler,
		},
		{
			MethodName: "GetDefaultMACSettings",
			Handler:    _Ns_GetDefaultMACSettings_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "lorawan-stack/api/networkserver.proto",
}

// AsNsClient is the client API for AsNs service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type AsNsClient interface {
	// Replace the entire downlink queue with the specified messages.
	// This can also be used to empty the queue by specifying no messages.
	// Note that this will trigger an immediate downlink if a downlink slot is available.
	DownlinkQueueReplace(ctx context.Context, in *DownlinkQueueRequest, opts ...grpc.CallOption) (*types.Empty, error)
	// Push downlink messages to the end of the downlink queue.
	// Note that this will trigger an immediate downlink if a downlink slot is available.
	DownlinkQueuePush(ctx context.Context, in *DownlinkQueueRequest, opts ...grpc.CallOption) (*types.Empty, error)
	// List the items currently in the downlink queue.
	DownlinkQueueList(ctx context.Context, in *EndDeviceIdentifiers, opts ...grpc.CallOption) (*ApplicationDownlinks, error)
}

type asNsClient struct {
	cc *grpc.ClientConn
}

func NewAsNsClient(cc *grpc.ClientConn) AsNsClient {
	return &asNsClient{cc}
}

func (c *asNsClient) DownlinkQueueReplace(ctx context.Context, in *DownlinkQueueRequest, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/ttn.lorawan.v3.AsNs/DownlinkQueueReplace", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *asNsClient) DownlinkQueuePush(ctx context.Context, in *DownlinkQueueRequest, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/ttn.lorawan.v3.AsNs/DownlinkQueuePush", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *asNsClient) DownlinkQueueList(ctx context.Context, in *EndDeviceIdentifiers, opts ...grpc.CallOption) (*ApplicationDownlinks, error) {
	out := new(ApplicationDownlinks)
	err := c.cc.Invoke(ctx, "/ttn.lorawan.v3.AsNs/DownlinkQueueList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AsNsServer is the server API for AsNs service.
type AsNsServer interface {
	// Replace the entire downlink queue with the specified messages.
	// This can also be used to empty the queue by specifying no messages.
	// Note that this will trigger an immediate downlink if a downlink slot is available.
	DownlinkQueueReplace(context.Context, *DownlinkQueueRequest) (*types.Empty, error)
	// Push downlink messages to the end of the downlink queue.
	// Note that this will trigger an immediate downlink if a downlink slot is available.
	DownlinkQueuePush(context.Context, *DownlinkQueueRequest) (*types.Empty, error)
	// List the items currently in the downlink queue.
	DownlinkQueueList(context.Context, *EndDeviceIdentifiers) (*ApplicationDownlinks, error)
}

// UnimplementedAsNsServer can be embedded to have forward compatible implementations.
type UnimplementedAsNsServer struct {
}

func (*UnimplementedAsNsServer) DownlinkQueueReplace(ctx context.Context, req *DownlinkQueueRequest) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DownlinkQueueReplace not implemented")
}
func (*UnimplementedAsNsServer) DownlinkQueuePush(ctx context.Context, req *DownlinkQueueRequest) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DownlinkQueuePush not implemented")
}
func (*UnimplementedAsNsServer) DownlinkQueueList(ctx context.Context, req *EndDeviceIdentifiers) (*ApplicationDownlinks, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DownlinkQueueList not implemented")
}

func RegisterAsNsServer(s *grpc.Server, srv AsNsServer) {
	s.RegisterService(&_AsNs_serviceDesc, srv)
}

func _AsNs_DownlinkQueueReplace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DownlinkQueueRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AsNsServer).DownlinkQueueReplace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ttn.lorawan.v3.AsNs/DownlinkQueueReplace",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AsNsServer).DownlinkQueueReplace(ctx, req.(*DownlinkQueueRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AsNs_DownlinkQueuePush_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DownlinkQueueRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AsNsServer).DownlinkQueuePush(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ttn.lorawan.v3.AsNs/DownlinkQueuePush",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AsNsServer).DownlinkQueuePush(ctx, req.(*DownlinkQueueRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AsNs_DownlinkQueueList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EndDeviceIdentifiers)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AsNsServer).DownlinkQueueList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ttn.lorawan.v3.AsNs/DownlinkQueueList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AsNsServer).DownlinkQueueList(ctx, req.(*EndDeviceIdentifiers))
	}
	return interceptor(ctx, in, info, handler)
}

var _AsNs_serviceDesc = grpc.ServiceDesc{
	ServiceName: "ttn.lorawan.v3.AsNs",
	HandlerType: (*AsNsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "DownlinkQueueReplace",
			Handler:    _AsNs_DownlinkQueueReplace_Handler,
		},
		{
			MethodName: "DownlinkQueuePush",
			Handler:    _AsNs_DownlinkQueuePush_Handler,
		},
		{
			MethodName: "DownlinkQueueList",
			Handler:    _AsNs_DownlinkQueueList_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "lorawan-stack/api/networkserver.proto",
}

// GsNsClient is the client API for GsNs service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type GsNsClient interface {
	// Called by the Gateway Server when an uplink message arrives.
	HandleUplink(ctx context.Context, in *UplinkMessage, opts ...grpc.CallOption) (*types.Empty, error)
	// Called by the Gateway Server when a Tx acknowledgment arrives.
	ReportTxAcknowledgment(ctx context.Context, in *GatewayTxAcknowledgment, opts ...grpc.CallOption) (*types.Empty, error)
}

type gsNsClient struct {
	cc *grpc.ClientConn
}

func NewGsNsClient(cc *grpc.ClientConn) GsNsClient {
	return &gsNsClient{cc}
}

func (c *gsNsClient) HandleUplink(ctx context.Context, in *UplinkMessage, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/ttn.lorawan.v3.GsNs/HandleUplink", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gsNsClient) ReportTxAcknowledgment(ctx context.Context, in *GatewayTxAcknowledgment, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/ttn.lorawan.v3.GsNs/ReportTxAcknowledgment", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GsNsServer is the server API for GsNs service.
type GsNsServer interface {
	// Called by the Gateway Server when an uplink message arrives.
	HandleUplink(context.Context, *UplinkMessage) (*types.Empty, error)
	// Called by the Gateway Server when a Tx acknowledgment arrives.
	ReportTxAcknowledgment(context.Context, *GatewayTxAcknowledgment) (*types.Empty, error)
}

// UnimplementedGsNsServer can be embedded to have forward compatible implementations.
type UnimplementedGsNsServer struct {
}

func (*UnimplementedGsNsServer) HandleUplink(ctx context.Context, req *UplinkMessage) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HandleUplink not implemented")
}
func (*UnimplementedGsNsServer) ReportTxAcknowledgment(ctx context.Context, req *GatewayTxAcknowledgment) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReportTxAcknowledgment not implemented")
}

func RegisterGsNsServer(s *grpc.Server, srv GsNsServer) {
	s.RegisterService(&_GsNs_serviceDesc, srv)
}

func _GsNs_HandleUplink_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UplinkMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GsNsServer).HandleUplink(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ttn.lorawan.v3.GsNs/HandleUplink",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GsNsServer).HandleUplink(ctx, req.(*UplinkMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _GsNs_ReportTxAcknowledgment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GatewayTxAcknowledgment)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GsNsServer).ReportTxAcknowledgment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ttn.lorawan.v3.GsNs/ReportTxAcknowledgment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GsNsServer).ReportTxAcknowledgment(ctx, req.(*GatewayTxAcknowledgment))
	}
	return interceptor(ctx, in, info, handler)
}

var _GsNs_serviceDesc = grpc.ServiceDesc{
	ServiceName: "ttn.lorawan.v3.GsNs",
	HandlerType: (*GsNsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "HandleUplink",
			Handler:    _GsNs_HandleUplink_Handler,
		},
		{
			MethodName: "ReportTxAcknowledgment",
			Handler:    _GsNs_ReportTxAcknowledgment_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "lorawan-stack/api/networkserver.proto",
}

// NsEndDeviceRegistryClient is the client API for NsEndDeviceRegistry service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type NsEndDeviceRegistryClient interface {
	// Get returns the device that matches the given identifiers.
	// If there are multiple matches, an error will be returned.
	Get(ctx context.Context, in *GetEndDeviceRequest, opts ...grpc.CallOption) (*EndDevice, error)
	// Set creates or updates the device.
	Set(ctx context.Context, in *SetEndDeviceRequest, opts ...grpc.CallOption) (*EndDevice, error)
	// ResetFactoryDefaults resets device state to factory defaults.
	ResetFactoryDefaults(ctx context.Context, in *ResetAndGetEndDeviceRequest, opts ...grpc.CallOption) (*EndDevice, error)
	// Delete deletes the device that matches the given identifiers.
	// If there are multiple matches, an error will be returned.
	Delete(ctx context.Context, in *EndDeviceIdentifiers, opts ...grpc.CallOption) (*types.Empty, error)
}

type nsEndDeviceRegistryClient struct {
	cc *grpc.ClientConn
}

func NewNsEndDeviceRegistryClient(cc *grpc.ClientConn) NsEndDeviceRegistryClient {
	return &nsEndDeviceRegistryClient{cc}
}

func (c *nsEndDeviceRegistryClient) Get(ctx context.Context, in *GetEndDeviceRequest, opts ...grpc.CallOption) (*EndDevice, error) {
	out := new(EndDevice)
	err := c.cc.Invoke(ctx, "/ttn.lorawan.v3.NsEndDeviceRegistry/Get", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nsEndDeviceRegistryClient) Set(ctx context.Context, in *SetEndDeviceRequest, opts ...grpc.CallOption) (*EndDevice, error) {
	out := new(EndDevice)
	err := c.cc.Invoke(ctx, "/ttn.lorawan.v3.NsEndDeviceRegistry/Set", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nsEndDeviceRegistryClient) ResetFactoryDefaults(ctx context.Context, in *ResetAndGetEndDeviceRequest, opts ...grpc.CallOption) (*EndDevice, error) {
	out := new(EndDevice)
	err := c.cc.Invoke(ctx, "/ttn.lorawan.v3.NsEndDeviceRegistry/ResetFactoryDefaults", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nsEndDeviceRegistryClient) Delete(ctx context.Context, in *EndDeviceIdentifiers, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/ttn.lorawan.v3.NsEndDeviceRegistry/Delete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NsEndDeviceRegistryServer is the server API for NsEndDeviceRegistry service.
type NsEndDeviceRegistryServer interface {
	// Get returns the device that matches the given identifiers.
	// If there are multiple matches, an error will be returned.
	Get(context.Context, *GetEndDeviceRequest) (*EndDevice, error)
	// Set creates or updates the device.
	Set(context.Context, *SetEndDeviceRequest) (*EndDevice, error)
	// ResetFactoryDefaults resets device state to factory defaults.
	ResetFactoryDefaults(context.Context, *ResetAndGetEndDeviceRequest) (*EndDevice, error)
	// Delete deletes the device that matches the given identifiers.
	// If there are multiple matches, an error will be returned.
	Delete(context.Context, *EndDeviceIdentifiers) (*types.Empty, error)
}

// UnimplementedNsEndDeviceRegistryServer can be embedded to have forward compatible implementations.
type UnimplementedNsEndDeviceRegistryServer struct {
}

func (*UnimplementedNsEndDeviceRegistryServer) Get(ctx context.Context, req *GetEndDeviceRequest) (*EndDevice, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (*UnimplementedNsEndDeviceRegistryServer) Set(ctx context.Context, req *SetEndDeviceRequest) (*EndDevice, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Set not implemented")
}
func (*UnimplementedNsEndDeviceRegistryServer) ResetFactoryDefaults(ctx context.Context, req *ResetAndGetEndDeviceRequest) (*EndDevice, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResetFactoryDefaults not implemented")
}
func (*UnimplementedNsEndDeviceRegistryServer) Delete(ctx context.Context, req *EndDeviceIdentifiers) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}

func RegisterNsEndDeviceRegistryServer(s *grpc.Server, srv NsEndDeviceRegistryServer) {
	s.RegisterService(&_NsEndDeviceRegistry_serviceDesc, srv)
}

func _NsEndDeviceRegistry_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetEndDeviceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NsEndDeviceRegistryServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ttn.lorawan.v3.NsEndDeviceRegistry/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NsEndDeviceRegistryServer).Get(ctx, req.(*GetEndDeviceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NsEndDeviceRegistry_Set_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetEndDeviceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NsEndDeviceRegistryServer).Set(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ttn.lorawan.v3.NsEndDeviceRegistry/Set",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NsEndDeviceRegistryServer).Set(ctx, req.(*SetEndDeviceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NsEndDeviceRegistry_ResetFactoryDefaults_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResetAndGetEndDeviceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NsEndDeviceRegistryServer).ResetFactoryDefaults(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ttn.lorawan.v3.NsEndDeviceRegistry/ResetFactoryDefaults",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NsEndDeviceRegistryServer).ResetFactoryDefaults(ctx, req.(*ResetAndGetEndDeviceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NsEndDeviceRegistry_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EndDeviceIdentifiers)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NsEndDeviceRegistryServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ttn.lorawan.v3.NsEndDeviceRegistry/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NsEndDeviceRegistryServer).Delete(ctx, req.(*EndDeviceIdentifiers))
	}
	return interceptor(ctx, in, info, handler)
}

var _NsEndDeviceRegistry_serviceDesc = grpc.ServiceDesc{
	ServiceName: "ttn.lorawan.v3.NsEndDeviceRegistry",
	HandlerType: (*NsEndDeviceRegistryServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _NsEndDeviceRegistry_Get_Handler,
		},
		{
			MethodName: "Set",
			Handler:    _NsEndDeviceRegistry_Set_Handler,
		},
		{
			MethodName: "ResetFactoryDefaults",
			Handler:    _NsEndDeviceRegistry_ResetFactoryDefaults_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _NsEndDeviceRegistry_Delete_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "lorawan-stack/api/networkserver.proto",
}
